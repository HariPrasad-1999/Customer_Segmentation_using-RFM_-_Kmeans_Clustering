# -*- coding: utf-8 -*-
"""final (3).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18xdS3Itlr_2B8yvk9w3YQ3-UUvRqrODf
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

dataset=pd.read_csv(r'/content/up2restaurant.csv', encoding='unicode_escape')
#dataset.head()

#dataset.shape

# Detailing the Country distribution and customerid
country_data = dataset[['Country','CustomerID']].drop_duplicates()
country_data.groupby(['Country']).agg({'CustomerID' : 'count'}).sort_values('CustomerID',ascending = False).reset_index().rename(columns = {'CustomerID':'CustomerID Count'})

dataset = dataset[dataset['Country'] == 'United Kingdom'].reset_index(drop = True)

#dataset.shape

dataset.isna().sum()
dataset= dataset[pd.notnull(dataset['CustomerID'])]

#Checking the description of the data
#dataset.describe()

#cityData=dataset[['Country','CustomerID']].drop_duplicates()
#cityData.groupby(['Country'])['CustomerID'].aggregate('count').reset_index().sort_values('CustomerID',ascending=False)

dataset=dataset.query("Country=='United Kingdom'").reset_index(drop =True)
#dataset.isnull().sum(axis=0)

#Remove  missing values from Customer ID column, can ignore missing values in description column

dataset=dataset[pd.notnull(dataset['CustomerID'])]
dataset = dataset.query("Quantity > 0")
#dataset.shape

#dataset.UnitPrice.min()

dataset=dataset[(dataset['Quantity']>0)]
dataset['InvoiceDate'] = pd.to_datetime(dataset['InvoiceDate'])
#print(dataset['InvoiceDate']) 
dataset['TotalAmount']= dataset['Quantity'] * dataset['UnitPrice']
#print(dataset['TotalAmount']) 
#dataset.shape

#dataset.tail()

"""# RFM Modelling

## What Is Recency, Frequency, Monetary Value (RFM)?
Recency, frequency, monetary value is a marketing analysis tool used to identify a company's or an organization's best customers by using certain measures. The RFM model is based on three quantitative factors:


Recency: How recently a customer has made a purchase
Frequency: How often a customer makes a purchase
Monetary Value: How much money a customer spends on purchases
"""

import datetime as  dt

dataset['InvoiceDate']=pd.to_datetime(dataset['InvoiceDate'])
#dataset['InvoiceDate'].max()

#recency= latest date - last Inovice Data
#Frequency=count of invoice no.of  transcation(s)
#Monetary =sum of Total
#Amount for each customer

import datetime as  dt

#set Latest date 2011-12-10 as last invoice date was 2011-12-09.this is to caluculate the number of days from recent purchase

latest_Date=dt.datetime(2011,12,10)

ld = pd.to_datetime(latest_Date)

RFMScores =dataset.groupby('CustomerID').agg({'InvoiceDate': lambda x: (latest_Date -x.max()).days,
                                                                        'InvoiceNo':lambda x: len(x),
                                                                       'TotalAmount':lambda x: x.sum()})


#Convert Invoice Date into type int
RFMScores['InvoiceDate']= RFMScores['InvoiceDate'] = RFMScores['InvoiceDate'].astype(int)


#RENAME COLUMN NAMES TO RECENCY, FREQUENCY, AND MONETARY

RFMScores.rename(columns={'InvoiceDate':'Recency',
                         'InvoiceNo':'Frequency',
                         'TotalAmount':'Monetary'}, inplace =True)


#RFMScores.reset_index()

#DESCRIPTIVE STATISTICS
#RFMScores.Recency.describe()

#RECENCY DISTRIBUTION PLOT
import seaborn as sns

x=RFMScores['Recency']
#ax= sns.distplot(x)

#RFMScores.Frequency.describe()

x=RFMScores.query('Frequency < 500')['Frequency']
#ax= sns.distplot(x)

#RFMScores.Monetary.describe()

x=RFMScores.query('Monetary < 500')['Monetary']
#ax= sns.distplot(x)

#Split into four Segments using quantiles
quantiles =RFMScores.quantile(q=[0.25,0.5,0.75])
quantiles =quantiles.to_dict()
#quantiles

#FUNCTIONS TO CREATE R, F AND M SEGMENTS
#imp
def RScoring(x,p,d):
    if x <= d[p][0.25]:
        return 1
    elif x <= d[p][0.50]:
        return 2
    elif x <= d[p][0.75]:
        return 3
    else:
        return 4
def FnMScoring(x,p,d):
    if x <=d[p][0.25]:
        return 4
    elif x <= d[p][0.50]:
        return 3
    elif x <= d[p][0.75]:
        return 2
    else:
        return 1

#calculate ADD R, F AND M SEGMENT VALUE COLUMNS IN THE EXISTING DATASET TO SHOW R, F, AND M SEGMENT VALUES

RFMScores['R']= RFMScores['Recency'].apply(RScoring, args=('Recency',quantiles,))
RFMScores['F']= RFMScores['Frequency'].apply(FnMScoring, args=('Frequency',quantiles,))
RFMScores['M']= RFMScores['Monetary'].apply(FnMScoring, args=('Monetary',quantiles,))

#RFMScores.head()

#calculate and Add RFM group value column showing combined concatenated score of RFM
RFMScores['RFMGroup']=RFMScores.R.map(str) + RFMScores.F.map(str) + RFMScores.M.map(str)


#Calculate and Add RFMScore value column showing total sum of RFM Group values

RFMScores['RFMScore'] =RFMScores[['R' ,'F', 'M']].sum(axis = 1)
#RFMScores.reset_index()

#assign loyalty level to each customer

loyaltyLevel=['HIGHLY VISITED', 'REGULAR', 'OCCASIONALLY VISITED', 'NEW VISITORS']
scoreCuts= pd.qcut(RFMScores.RFMScore, q=4, labels=loyaltyLevel,duplicates="drop")
RFMScores['RFM_Loyalty_Level']=scoreCuts.values

#RFMScores.reset_index()

#Validate the data for RFMGroup =111

#RFMScores[RFMScores['RFMGroup']=='111'].sort_values('Monetary', ascending=False).reset_index().head(10)

"""### Recency Vs Frequency"""

!pip install -q plotly==4.2.1
!pip install chart_studio

import chart_studio as cs
import plotly.offline as po
import plotly.graph_objs as gobj

#Recency Vs Frequency

graph = RFMScores.query("Monetary < 50000 and Frequency < 2000 ")

plot_data =[ gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'NEW VISITORS'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='NEW VISITORS'")['Frequency'],
                          mode='markers',
                          name='NEW VISITORS' ,
                          marker =dict(size =7,
                                      line=dict(width=1),
                                      color='blue',
                                      opacity =0.8
                                      )
                         ),
             gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'OCCASIONALLY VISITED'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='OCCASIONALLY VISITED'")['Frequency'],
                          mode='markers',
                          name='OCCASIONALLY VISITED' ,
                          marker =dict(size =9,
                                      line=dict(width=1),
                                      color='green',
                                      opacity =0.5
                                      )
                         ),
             gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'REGULAR'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='REGULAR'")['Frequency'],
                          mode='markers',
                          name='REGULAR' ,
                          marker =dict(size =11,
                                      line=dict(width=1),
                                      color='red',
                                      opacity =0.9
                                      )
                         ),
            gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'HIGHLY VISITED'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='HIGHLY VISITED'")['Frequency'],
                          mode='markers',
                          name='HIGHLY VISITED' ,
                          marker =dict(size =13,
                                      line=dict(width=1),
                                      color='black',
                                      opacity =0.9
                                      )
                         ),
           ]

plot_layout =gobj.Layout(
    yaxis={'title':"Frequency"},
    xaxis={'title':'Recency'},
    title='Segments'
)

fig = gobj.Figure(data=plot_data,layout=plot_layout)
#po.iplot(fig)

"""#### FREQUENCY VS MONETARY"""

graph = RFMScores.query("Monetary < 50000 and Frequency < 2000 ")

plot_data =[ gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'NEW VISITORS'")['Frequency'], 
                          y=graph.query("RFM_Loyalty_Level =='NEW VISITORS'")['Monetary'],
                          mode='markers',
                          name='NEW VISITORS' ,
                          marker =dict(size =7,
                                      line=dict(width=1),
                                      color='blue',
                                      opacity =0.8
                                      )
                         ),
             gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'OCCASIONALLY VISITED'")['Frequency'], 
                          y=graph.query("RFM_Loyalty_Level =='OCCASIONALLY VISITED'")['Monetary'],
                          mode='markers',
                          name='OCCASIONALLY VISITED' ,
                          marker =dict(size =9,
                                      line=dict(width=1),
                                      color='green',
                                      opacity =0.5
                                      )
                         ),
             gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'REGULAR'")['Frequency'], 
                          y=graph.query("RFM_Loyalty_Level =='REGULAR'")['Monetary'],
                          mode='markers',
                          name='REGULAR' ,
                          marker =dict(size =11,
                                      line=dict(width=1),
                                      color='red',
                                      opacity =0.9
                                      )
                         ),
            gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'HIGHLY VISITED'")['Frequency'], 
                          y=graph.query("RFM_Loyalty_Level =='HIGHLY VISITED'")['Monetary'],
                          mode='markers',
                          name='HIGHLY VISITED' ,
                          marker =dict(size =13,
                                      line=dict(width=1),
                                      color='black',
                                      opacity =0.9
                                      )
                         ),
           ]

plot_layout =gobj.Layout(
    yaxis={'title':"Monetary"},
    xaxis={'title':'Frequency'},
    title='Segments'
)

fig = gobj.Figure(data=plot_data,layout=plot_layout)
#po.iplot(fig)

"""#### Recency vs Monetary"""

graph = RFMScores.query("Monetary < 50000 and Frequency < 2000 ")

plot_data =[ gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'NEW VISITORS'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='NEW VISITORS'")['Monetary'],
                          mode='markers',
                          name='NEW VISITORS' ,
                          marker =dict(size =7,
                                      line=dict(width=1),
                                      color='blue',
                                      opacity =0.8
                                      )
                         ),
             gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'OCCASIONALLY VISITED'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='OCCASIONALLY VISITED'")['Monetary'],
                          mode='markers',
                          name='OCCASIONALLY VISITED' ,
                          marker =dict(size =9,
                                      line=dict(width=1),
                                      color='green',
                                      opacity =0.5
                                      )
                         ),
             gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'REGULAR'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='REGULAR'")['Monetary'],
                          mode='markers',
                          name='REGULAR' ,
                          marker =dict(size =11,
                                      line=dict(width=1),
                                      color='red',
                                      opacity =0.9
                                      )
                         ),
            gobj.Scatter(x=graph.query("RFM_Loyalty_Level == 'HIGHLY VISITED'")['Recency'], 
                          y=graph.query("RFM_Loyalty_Level =='HIGHLY VISITED'")['Monetary'],
                          mode='markers',
                          name='HIGHLY VISITED' ,
                          marker =dict(size =13,
                                      line=dict(width=1),
                                      color='black',
                                      opacity =0.9
                                      )
                         ),
           ]

plot_layout =gobj.Layout(
    yaxis={'title':"Monetary"},
    xaxis={'title':'Recency'},
    title='Segments'
)

fig = gobj.Figure(data=plot_data,layout=plot_layout)
#po.iplot(fig)

"""# K-Means Clustering"""

#Handle negative and zero values so as to handle infinte nubers during log transformation
def handle_neg_n_zero(num):
    if num <=0:
        return 1
    else:
        return num
#handle_neg_n_zero function to Recency and Monetary columns

RFMScores['Recency'] = [handle_neg_n_zero(x) for x in RFMScores.Recency]
RFMScores['Monetary'] = [handle_neg_n_zero(x) for x in RFMScores.Monetary]


#performing log transformation to bring data into normal or near normal distribution

Log_Tfd_data = RFMScores[['Recency' , 'Frequency', 'Monetary']].apply(np.log, axis = 1).round(3)


#Log_Tfd_data

#Data distribution after data normalization for Recency

Recency_Plot =Log_Tfd_data['Recency']
#ax=sns.distplot(Recency_Plot)

#Data distribution after data normalization for Frequency

Frequency_Plot =Log_Tfd_data.query('Frequency < 1000')['Frequency']
#ax=sns.distplot(Frequency_Plot)

#Data distribution after data normalization for Monetary

Frequency_Plot =Log_Tfd_data.query('Frequency < 1000')['Frequency']
#ax=sns.distplot(Frequency_Plot)

#Data distribution after data normalization for Monetary

Monetary_Plot =Log_Tfd_data.query('Monetary < 1000')['Monetary']
#ax=sns.distplot(Monetary_Plot)

from sklearn.preprocessing import StandardScaler

# bring the data on same scale
scaleobj =StandardScaler()
Scaled_Data = scaleobj.fit_transform(Log_Tfd_data)

Scaled_Data = pd.DataFrame(Scaled_Data, index= RFMScores.index, columns = Log_Tfd_data.columns)

from sklearn.cluster import KMeans

sumOfSqDist = {}
for k in range(1,15):
    km=KMeans(n_clusters=k, init='k-means++', max_iter=1000)
    km=km.fit(Scaled_Data)
    sumOfSqDist[k] = km.inertia_
    
    
#plot the graph for sum of square distance values and Number of Clusters
sns.pointplot(x= list(sumOfSqDist.keys()),y= list(sumOfSqDist.values()))
plt.xlabel('number of Clusters(k)')
plt.ylabel('Sum of Square Distances')
plt.title('Elbow Method For Optimal K')
#plt.show()

#perform K-mean clustering or build the K-means clustering model

KMean_clust = KMeans(n_clusters= 4, init='k-means++', max_iter =1000)
KMean_clust.fit(Scaled_Data)
RFMScores['Cluster']= KMean_clust.labels_
RFMScores.tail()
#print(RFMScores['Cluster'])

from  matplotlib import pyplot as plt
plt.figure(figsize=(7,7))

##Scatter plot frequency VS Recency
colors=["red", "green", "blue","black"]
RFMScores['Color']= RFMScores['Cluster'].map(lambda p: colors[p])
#ax=RFMScores.plot(kind="scatter",
                 x="Recency",
                 y="Frequency",
                 figsize=(10,8),
                 c = RFMScores['Color'])

#RFMScores.head()

from sklearn.cluster import AgglomerativeClustering 

agglom = AgglomerativeClustering(n_clusters=4, linkage='average').fit(Scaled_Data)

Scaled_Data['Labels'] = agglom.labels_
RFMScores['Cluster']= agglom.labels_
plt.figure(figsize=(12, 8))
sns.scatterplot(Scaled_Data['Recency'], Scaled_Data['Frequency'], hue=Scaled_Data['Labels'], 
                palette=sns.color_palette('hls', 4))
plt.title('Agglomerative with 4 Clusters')
#plt.show()

#RFMScores.head()

from sklearn.cluster import DBSCAN 
db = DBSCAN(eps=0.4, min_samples=6).fit(Scaled_Data)

Scaled_Data['Labels'] = db.labels_
RFMScores['Cluster']= db.labels_
plt.figure(figsize=(12, 8))
sns.scatterplot(Scaled_Data['Recency'], Scaled_Data['Frequency'], hue=Scaled_Data['Labels'], 
                palette=sns.color_palette('hls', np.unique(db.labels_).shape[0]))
plt.title('DBSCAN with epsilon 11, min samples 6')
#plt.show()

#RFMScores.head()

from sklearn.cluster import MeanShift, estimate_bandwidth

# The following bandwidth can be automatically detected using
bandwidth = estimate_bandwidth(Scaled_Data, quantile=0.4)
ms = MeanShift(bandwidth).fit(Scaled_Data)
RFMScores['Cluster']= db.labels_
Scaled_Data['Labels'] = ms.labels_
plt.figure(figsize=(12, 8))
sns.scatterplot(Scaled_Data['Recency'], Scaled_Data['Frequency'], hue=Scaled_Data['Labels'], 
                palette=sns.color_palette('hls', np.unique(ms.labels_).shape[0]))
plt.plot()
plt.title('MeanShift')
#plt.show()

#RFMScores.head()



#perform K-mean clustering or build the K-means clustering model

KMean_clust = KMeans(n_clusters= 4, init='k-means++', max_iter =1000)
KMean_clust.fit(Scaled_Data)
RFMScores['Cluster']= KMean_clust.labels_
#RFMScores.tail()

ds=dataset[["CustomerID", "Phone No "]]
merging=RFMScores
merging=merging.reset_index()
leftds=pd.DataFrame(merging)
rightds=pd.DataFrame(ds)
merged_inner = pd.merge(left=leftds, right=rightds, left_on='CustomerID', right_on='CustomerID')
#merged_inner

md=merged_inner.drop(['CustomerID','Recency', 'Frequency','Monetary', 'R','F' ,'M','RFMGroup','RFMScore','Cluster','Color'], axis = 1)
#md

st=md.loc[md['RFM_Loyalty_Level'] =='REGULAR']
#md.loc[md['RFM_Loyalty_Level'] =='OCCASIONALLY VISITED']
#md.loc[md['RFM_Loyalty_Level'] =='HIGHLY VISITED']
#md.loc[md['RFM_Loyalty_Level'] =='NEW VISITORS']

print(st['Phone No '].astype(np.int64).unique())